package openfl.filters;


import lime.graphics.utils.ImageCanvasUtil;
import openfl._internal.renderer.RenderSession;
import openfl.display.BitmapData;
import openfl.display.Shader;
import openfl.filters.BitmapFilter;
import openfl.filters.FilterUtils;
import openfl.geom.Rectangle;


class BlurFilter extends BitmapFilter {
	
	private static var __blurShader = new BlurShader ();
	
	public var blurX (default, set):Float;
	public var blurY (default, set):Float;
	public var quality (default, set):Int;
		
		
	public function new (blurX:Float = 4, blurY:Float = 4, quality:Int = 1) {
		
		super ();
		
		this.blurX = blurX;
		this.blurY = blurY;
		this.quality = quality;

	}
	
	
	public override function clone ():BitmapFilter {
		
		return new BlurFilter (blurX, blurY, quality);
		
	}
	
	
	
	
	// Get & Set Methods
	
	
	private function set_blurX (value:Float):Float {
		
		if (value != blurX)
			__filterDirty = true;

		return blurX = value;
		
	}


	private function set_blurY (value:Float):Float {
		
		if (value != blurY)
			__filterDirty = true;
	
		return blurY = value;
		
	}
	
	
	private function set_quality (value:Int):Int {
		
		if (value != blurX)
			__filterDirty = true;
			
		return quality = value;
		
	}
	
	private override function __initShader (renderSession:RenderSession):Shader {
		
		var data = __blurShader.data;
		
		data.uBlurX[0] = blurX;
		data.uBlurY[0] = blurY;
		data.uQuality[0] = quality;
		
		return __blurShader;
		
	}


	private override function __getFilterBounds( sourceBitmapData:BitmapData ) : Rectangle {

		return new Rectangle( blurX, blurY, sourceBitmapData.width + blurX + blurX, sourceBitmapData.height + blurY + blurY );

	}


	private override function __renderFilter (sourceBitmapData:BitmapData, destBitmapData:BitmapData):Void {

		#if (js && html5)
		ImageCanvasUtil.convertToData (sourceBitmapData.image);
		ImageCanvasUtil.convertToData (destBitmapData.image);
		#end

		var source = sourceBitmapData.clone().image.data;
		var target = destBitmapData.image.data;

		FilterUtils.GaussianBlur( source, target, sourceBitmapData.width, sourceBitmapData.height, blurX, blurY );

		super.__renderFilter( sourceBitmapData, destBitmapData );
	}

}

private class BlurShader extends Shader {


	@:glFragmentSource( 
		
		"varying float vAlpha;
		varying vec2 vTexCoord;

		uniform sampler2D uImage0;
		
		uniform float uBlurX;
		uniform float uBlurY;
		uniform int uQuality;
		
		// automatically generated by GenerateGaussFunctionCode in  GaussianBlur.h
		vec3 GaussianBlur( sampler2D tex0, vec2 centreUV, vec2 halfPixelOffset, vec2 pixelOffset )
		{
			vec3 colOut = vec3( 0, 0, 0 );
			vec2 texCoordOffset;
			vec3 col;
			vec3 col1;
			vec3 col2;
			vec3 col1;
			vec3 col2;

			////////////////////////////////////////////////;
			// Kernel width 7 x 7
			//
			const int stepCount = 2;
			//
			// const float gWeights[2] = float[2]( 0.44908, 0.05092 );
			// const float gOffsets[2] = float[2]( 0.53805, 0.06278 );
			////////////////////////////////////////////////;

			// for ( int i = 0; i < stepCount; i++ )
			// {
			// 	vec2 texCoordOffset = gOffsets[i] * pixelOffset;
			// 	vec3 col = texture( tex0, centreUV + texCoordOffset ).xyz + texture( tex0, centreUV â€“ texCoordOffset ).xyz;
			// 	colOut += gWeights[i] * col;
			// }

			texCoordOffset = vec2(0.53805) * pixelOffset;
			col = texture2D( tex0, centreUV + texCoordOffset ).xyz + texture2D( tex0, centreUV - texCoordOffset ).xyz;
			colOut += 0.44908 * col;

			texCoordOffset = vec2(0.06278) * pixelOffset;
			col = texture2D( tex0, centreUV + texCoordOffset ).xyz + texture2D( tex0, centreUV - texCoordOffset ).xyz;
			colOut += 0.05092 * col;
			
			return colOut;
		}
		
		void main(void)
		{
			vec4 c = texture2D(uImage0, vTexCoord);

			gl_FragColor = vec4( GaussianBlur( uImage0, vTexCoord, vec2(0,0), vec2(0,0)), 1.0);

		}"
		
	)
	
	@:glVertexSource( 
		
		"attribute float aAlpha;
		attribute vec4 aPosition;
		attribute vec2 aTexCoord;
		
		varying float vAlpha;
		varying vec2 vTexCoord;
		
		uniform mat4 uMatrix;
		
		void main(void) {
			
			vAlpha = aAlpha;
			vTexCoord = aTexCoord;
			gl_Position = uMatrix * aPosition;
			
		}"
		
	)
	
	
	public function new () {
		
		super ();
		
		data.uBlurX.value = [ 4 ];
		data.uBlurY.value = [ 4 ];
		data.uQuality.value = [ 0 ];
		
	}
		
}
